[{"id":0,"href":"/docs/study/vulkan/chapter1/","title":"chapter1 基本概念","section":"vulkan学习","content":"\r基本流程\r#\r创建Instance 获得PhysicalDevice 获得Device "},{"id":1,"href":"/docs/study/vulkan/chapter1/first/","title":"Instance","section":"chapter1 基本概念","content":"\r基本流程\r#\rpublic class test{ } "},{"id":2,"href":"/docs/study/","title":"vulkan学习","section":"Docs","content":"\r介绍\r#\r"},{"id":3,"href":"/docs/study/vulkan/chapter2/","title":"chapter2 三角形出来","section":"vulkan学习","content":"\r三角形\r#\r"},{"id":4,"href":"/docs/study/vulkan/chapter3/","title":"chapter3 纹理","section":"vulkan学习","content":"\r三角形\r#\r"},{"id":5,"href":"/docs/study/vulkan/chapter1/device/","title":"设备","section":"chapter1 基本概念","content":"\r基本流程\r#\rpublic class test{ } "},{"id":6,"href":"/docs/study/vulkan/chapter4/","title":"chapter4 同步","section":"vulkan学习","content":"\rPipeline overview\r#\r"},{"id":7,"href":"/docs/study/vulkan/chapter4/1-pipeline/","title":"pipeline","section":"chapter4 同步","content":"\rPipeline overview\r#\rstage\r#\rTOP_OF_PIPE_BIT\nDRAW_INDIRECT_BIT\nVERTEX_INPUT_BIT\nVERTEX_SHADER_BIT\nTESSELLATION_CONTROL_SHADER_BIT\nTESSELLATION_EVALUATION_SHADER_BIT\nGEOMETRY_SHADER_BIT\nFRAGMENT_SHADER_BIT\nEARLY_FRAGMENT_TESTS_BIT\nLATE_FRAGMENT_TESTS_BIT\nCOLOR_ATTACHMENT_OUTPUT_BIT\nTRANSFER_BIT\nCOMPUTE_SHADER_BIT\nBOTTOM_OF_PIPE_BIT\nHOST_BIT\nALL_GRAPHICS_BIT\nALL_COMMANDS_BIT\nsource\r#\r生产阶段\ntarget\r#\r消费阶段\nsource 之后 target 之前\nvkCmdPipelineBarrier( commandBuffer, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, // source stage VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, // destination stage /* remaining parameters omitted */); 这种转换表示，GPU 上当前正在进行的所有命令都需要完成，然后才执行该转换，并且在它完成转换之前，不允许任何命令开始。这个障碍会等待一切完成，并阻止任何工作在它开始之前启动。\nvkCmdPipelineBarrier( commandBuffer, VK_PIPELINE_VERTEX_SHADER_BIT, // source stage VK_PIPELINE_COMPUTE_SHADER_BIT, // destination stage /* remaining parameters omitted */); If you write to a render target and read from it in a fragment shader, the stages would be VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT as the source and VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT as the destination – typical for G-Buffer rendering. For shadow maps, the source would be VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT. Another typical example is copying data – you produce the data through a copy, so the source stage would be set to VK_PIPELINE_STAGE_TRANSFER_BIT, and the destination to the stage where you need it. For vertex buffers, this would be for instance VK_PIPELINE_STAGE_VERTEX_INPUT_BIT.\nGenerally, you should try to maximize the number of “unblocked” stages, that is, produce data early and wait late for it. It’s always safe on the producer side to move towards the bottom of the pipe, as you’ll wait for more and more stages to finish, but it won’t improve performance. Similarly, if you want to be safe on the target side, you move upwards towards the top of pipe – but it prevents more stages from running, so that should be avoided as well.\nOne final remark: as mentioned previously, the hardware may not have all the stages internally, or may not be able to signal or wait at the specified stage. In those cases, the driver is free to move your source stage towards the bottom of the pipe and the target stage towards the top. This is implementation-specific though, and you should not have to worry about this – your goal should be to set the stages as “tight” as possible and minimize the number the blocked stages.\n来源\nIf a synchronization command includes a source stage mask, its first synchronization scope only includes execution of the pipeline stages specified in that mask and any logically earlier stages. Its first access scope only includes memory accesses performed by pipeline stages explicitly specified in the source stage mask.\nIf a synchronization command includes a destination stage mask, its second synchronization scope only includes execution of the pipeline stages specified in that mask and any logically later stages. Its second access scope only includes memory accesses performed by pipeline stages explicitly specified in the destination stage mask.\n"},{"id":8,"href":"/docs/study/vulkan/chapter4/2-blit/","title":"vkCmdBlitImage","section":"chapter4 同步","content":"要在原始图像的基础上生成 Mipmap，可以通过使用多个图像传输操作来实现。在每个 Mipmap 级别，图像的尺寸会减小一半，并且可以根据需要使用不同的过滤器来处理像素数据。\n以下是一个基于原始图像生成 Mipmap 的简单示例：\n// 1. 创建源和目标图像的视图 // 创建源图像视图 VkImageViewCreateInfo srcImageViewInfo = {}; srcImageViewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO; srcImageViewInfo.image = srcImage; // srcImage 是原始图像 srcImageViewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D; srcImageViewInfo.format = srcFormat; // srcFormat 是原始图像格式 srcImageViewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; srcImageViewInfo.subresourceRange.baseMipLevel = 0; srcImageViewInfo.subresourceRange.levelCount = 1; srcImageViewInfo.subresourceRange.baseArrayLayer = 0; srcImageViewInfo.subresourceRange.layerCount = 1; VkImageView srcImageView; vkCreateImageView(device, \u0026amp;srcImageViewInfo, nullptr, \u0026amp;srcImageView); // 创建目标图像视图 VkImageViewCreateInfo dstImageViewInfo = {}; dstImageViewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO; dstImageViewInfo.image = srcImage; // 目标图像和原始图像使用同一个图像对象 dstImageViewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D; dstImageViewInfo.format = srcFormat; // 目标图像和原始图像使用相同的格式 dstImageViewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; dstImageViewInfo.subresourceRange.baseMipLevel = 1; // 从第二级 Mipmap 开始 dstImageViewInfo.subresourceRange.levelCount = mipLevels - 1; // 总共 mipLevels - 1 个 Mipmap 级别 dstImageViewInfo.subresourceRange.baseArrayLayer = 0; dstImageViewInfo.subresourceRange.layerCount = 1; VkImageView dstImageView; vkCreateImageView(device, \u0026amp;dstImageViewInfo, nullptr, \u0026amp;dstImageView); // 2. 生成 Mipmap VkCommandBuffer commandBuffer; // 假设已创建好的命令缓冲区 // 开始录制命令缓冲区 VkCommandBufferBeginInfo beginInfo = {}; beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO; vkBeginCommandBuffer(commandBuffer, \u0026amp;beginInfo); // 获取原始图像的尺寸 int32_t width = originalWidth; int32_t height = originalHeight; for (uint32_t i = 1; i \u0026lt; mipLevels; ++i) { // 计算当前 Mipmap 级别的尺寸 width = std::max(1, width / 2); height = std::max(1, height / 2); // 设置 Mipmap 层级 VkImageBlit blitRegion = {}; blitRegion.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; blitRegion.srcSubresource.baseArrayLayer = 0; blitRegion.srcSubresource.mipLevel = i - 1; blitRegion.srcOffsets[1].x = width; blitRegion.srcOffsets[1].y = height; blitRegion.srcOffsets[1].z = 1; blitRegion.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; blitRegion.dstSubresource.baseArrayLayer = 0; blitRegion.dstSubresource.mipLevel = i; blitRegion.dstOffsets[1].x = std::max(1, width / 2); blitRegion.dstOffsets[1].y = std::max(1, height / 2); blitRegion.dstOffsets[1].z = 1; // 执行图像传输操作 vkCmdBlitImage(commandBuffer, srcImage, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, srcImage, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, \u0026amp;blitRegion, VK_FILTER_LINEAR); // 设置图像布局，以便下一次传输 VkImageMemoryBarrier barrier = {}; barrier.sType = VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER; barrier.srcAccessMask = VK_ACCESS_TRANSFER_WRITE_BIT; barrier.dstAccessMask = VK_ACCESS_TRANSFER_READ_BIT; barrier.oldLayout = VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL; barrier.newLayout = VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL; barrier.srcQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED; barrier.dstQueueFamilyIndex = VK_QUEUE_FAMILY_IGNORED; barrier.image = srcImage; barrier.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; barrier.subresourceRange.baseMipLevel = i; barrier.subresourceRange.levelCount = 1; barrier.subresourceRange.baseArrayLayer = 0; barrier.subresourceRange.layerCount = 1; vkCmdPipelineBarrier(commandBuffer, VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT, 0, 0, nullptr, 0, nullptr, 1, \u0026amp;barrier); } // 结束录制命令缓冲区 vkEndCommandBuffer(commandBuffer); // 提交命令缓冲区 VkSubmitInfo submitInfo = {}; submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO; submitInfo.commandBufferCount = 1; submitInfo.pCommandBuffers = \u0026amp;commandBuffer; vkQueueSubmit(queue, 1, \u0026amp;submitInfo, VK_NULL_HANDLE); vkQueueWaitIdle(queue); // 等待队列执行完毕 // 清理资源 vkDestroyImageView(device, srcImageView, nullptr); vkDestroyImageView(device, dstImageView, nullptr); 这段代码首先创建了源图像和目标图像的视图。然后，在循环中对每个 Mipmap 级别执行图像传输操作，将源图像的内容传输到相应的目标图像中。在每次传输后，通过内存屏障设置图像布局，以便下一次传输操作。最后，提交命令缓冲区并清理资源。\nVkCommandBuffer commandBuffer; // 假设已创建好的命令缓冲区 // 开始录制命令缓冲区 VkCommandBufferBeginInfo beginInfo = {}; beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO; vkBeginCommandBuffer(commandBuffer, \u0026amp;beginInfo); // 设置源和目标区域 VkImageBlit blitRegion = {}; blitRegion.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; blitRegion.srcSubresource.mipLevel = 0; blitRegion.srcSubresource.baseArrayLayer = 0; blitRegion.srcSubresource.layerCount = 1; blitRegion.srcOffsets[0] = {0, 0, 0}; // 源图像起始坐标 blitRegion.srcOffsets[1] = {512, 512, 1}; // 源图像结束坐标 blitRegion.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; blitRegion.dstSubresource.mipLevel = 0; blitRegion.dstSubresource.baseArrayLayer = 0; blitRegion.dstSubresource.layerCount = 1; blitRegion.dstOffsets[0] = {0, 0, 0}; // 目标图像起始坐标 blitRegion.dstOffsets[1] = {256, 256, 1}; // 目标图像结束坐标 // 执行图像传输操作 vkCmdBlitImage(commandBuffer, srcImage, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, dstImage, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, \u0026amp;blitRegion, VK_FILTER_LINEAR); // 结束录制命令缓冲区 vkEndCommandBuffer(commandBuffer); // 提交命令缓冲区 VkSubmitInfo submitInfo = {}; submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO; submitInfo.commandBufferCount = 1; submitInfo.pCommandBuffers = \u0026amp;commandBuffer; vkQueueSubmit(queue, 1, \u0026amp;submitInfo, VK_NULL_HANDLE); vkQueueWaitIdle(queue); // 等待队列执行完毕 如果你想在同一场景中同时使用高分辨率和低分辨率的图像，你可以在渲染过程中针对不同的图像视图使用不同的分辨率。\n以下是一个示例代码，演示了如何在同一场景中同时使用高分辨率和低分辨率的图像：\nVkCommandBuffer commandBuffer; // 假设已创建好的命令缓冲区 // 开始录制命令缓冲区 VkCommandBufferBeginInfo beginInfo = {}; beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO; vkBeginCommandBuffer(commandBuffer, \u0026amp;beginInfo); // 设置高分辨率图像的源和目标区域 VkImageBlit highResBlitRegion = {}; highResBlitRegion.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; highResBlitRegion.srcSubresource.mipLevel = 0; highResBlitRegion.srcSubresource.baseArrayLayer = 0; highResBlitRegion.srcSubresource.layerCount = 1; highResBlitRegion.srcOffsets[0] = {0, 0, 0}; // 高分辨率图像起始坐标 highResBlitRegion.srcOffsets[1] = {512, 512, 1}; // 高分辨率图像结束坐标 highResBlitRegion.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; highResBlitRegion.dstSubresource.mipLevel = 0; highResBlitRegion.dstSubresource.baseArrayLayer = 0; highResBlitRegion.dstSubresource.layerCount = 1; highResBlitRegion.dstOffsets[0] = {0, 0, 0}; // 目标图像起始坐标（高分辨率） highResBlitRegion.dstOffsets[1] = {512, 512, 1}; // 目标图像结束坐标（高分辨率） // 设置低分辨率图像的源和目标区域 VkImageBlit lowResBlitRegion = {}; lowResBlitRegion.srcSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; lowResBlitRegion.srcSubresource.mipLevel = 0; lowResBlitRegion.srcSubresource.baseArrayLayer = 0; lowResBlitRegion.srcSubresource.layerCount = 1; lowResBlitRegion.srcOffsets[0] = {0, 0, 0}; // 低分辨率图像起始坐标 lowResBlitRegion.srcOffsets[1] = {256, 256, 1}; // 低分辨率图像结束坐标 lowResBlitRegion.dstSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; lowResBlitRegion.dstSubresource.mipLevel = 0; lowResBlitRegion.dstSubresource.baseArrayLayer = 0; lowResBlitRegion.dstSubresource.layerCount = 1; lowResBlitRegion.dstOffsets[0] = {0, 0, 0}; // 目标图像起始坐标（低分辨率） lowResBlitRegion.dstOffsets[1] = {256, 256, 1}; // 目标图像结束坐标（低分辨率） // 执行高分辨率图像传输操作 vkCmdBlitImage(commandBuffer, highResSrcImage, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, highResDstImage, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, \u0026amp;highResBlitRegion, VK_FILTER_LINEAR); // 执行低分辨率图像传输操作 vkCmdBlitImage(commandBuffer, lowResSrcImage, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, lowResDstImage, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, \u0026amp;lowResBlitRegion, VK_FILTER_LINEAR); // 结束录制命令缓冲区 vkEndCommandBuffer(commandBuffer); // 提交命令缓冲区 VkSubmitInfo submitInfo = {}; submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO; submitInfo.commandBufferCount = 1; submitInfo.pCommandBuffers = \u0026amp;commandBuffer; vkQueueSubmit(queue, 1, \u0026amp;submitInfo, VK_NULL_HANDLE); vkQueueWaitIdle(queue); // 等待队列执行完毕 在这个示例中，我们有两个图像对：一个用于高分辨率图像，另一个用于低分辨率图像。我们分别设置了两个不同的源和目标区域，然后使用 vkCmdBlitImage 分别执行高分辨率和低分辨率图像的传输操作。这样，在渲染过程中，你可以同时使用这两个图像对，每个图像对代表了不同的分辨率。\nhighResDstImage 和 lowResDstImage 可以是同一个图像视图（imageView）。在 Vulkan 中，图像视图描述了对图像数据的一种访问方式，而图像对象则是实际存储图像数据的资源。因此，可以在同一个图像对象上创建多个不同的图像视图，以便在不同的场景中使用。\n在上面的示例中，如果 highResDstImage 和 lowResDstImage 是同一个图像对象的不同视图，那么你可以使用同一个图像对象来存储不同分辨率的图像数据。这样可以节省内存，并且在进行图像传输操作时，你可以在同一个图像对象上进行读写操作，而不需要额外的资源。\n当使用同一个图像对象时，你可以在创建图像视图时指定不同的 Mipmap 级别来表示不同分辨率的图像数据。以下是一个示例代码：\nVkImageViewCreateInfo imageViewInfo = {}; imageViewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO; imageViewInfo.image = dstImage; // dstImage 是同一个图像对象 imageViewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D; imageViewInfo.format = VK_FORMAT_RGBA8_SRGB; // 假设图像格式为 RGBA8 SRGB imageViewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; imageViewInfo.subresourceRange.baseMipLevel = 0; imageViewInfo.subresourceRange.levelCount = mipLevels; // mipLevels 是总 Mipmap 级别数 imageViewInfo.subresourceRange.baseArrayLayer = 0; imageViewInfo.subresourceRange.layerCount = 1; VkImageView imageView; vkCreateImageView(device, \u0026amp;imageViewInfo, nullptr, \u0026amp;imageView); 在上面的示例中，dstImage 是同一个图像对象，我们通过创建一个图像视图 imageView 来访问图像数据。在创建图像视图时，我们通过设置 baseMipLevel 和 levelCount 来指定视图使用的 Mipmap 级别范围。通过设置不同的 Mipmap 级别范围，可以在同一个图像对象上创建多个图像视图，每个视图表示不同分辨率的图像数据。\n假设 mipLevels 是总共的 Mipmap 级别数，那么可以通过调整 baseMipLevel 和 levelCount 来表示不同分辨率的图像数据。例如，如果要表示高分辨率图像数据，可以将 baseMipLevel 设置为 0，levelCount 设置为总 Mipmap 级别数；如果要表示低分辨率图像数据，可以将 baseMipLevel 设置为某个较小的值，levelCount 设置为相应的 Mipmap 级别数。\n"},{"id":9,"href":"/posts/hello/","title":"图形学学习资源","section":"Blog","content":"\rhttps://gpuopen.com/learn/\n"},{"id":10,"href":"/posts/math/math1/","title":"math","section":"Math","content":"\rAcerbo datus maxime\r#\rabc\n"},{"id":11,"href":"/posts/math/","title":"Math","section":"Blog","content":"\rAcerbo datus maxime\r#\rAstris ipse furtiva\r#\rEst in vagis et Pittheus tu arge accipiter regia iram vocatur nurus. Omnes ut olivae sensit arma sorori deducit, inesset crudus, ego vetuere aliis, modo arsit? Utinam rapta fiducia valuere litora adicit cursu, ad facies\nSuis quot vota\r#\rEa furtique risere fratres edidit terrae magis. Colla tam mihi tenebat: miseram excita suadent es pecudes iam. Concilio quam velatus posset ait quod nunc! Fragosis suae dextra geruntur functus vulgata.\nTempora nisi nunc\r#\rLorem markdownum emicat gestu. Cannis sol pressit ducta. Est Idaei, tremens ausim se tutaeque, illi ulnis hausit, sed, lumina cutem. Quae avis sequens!\nvar panel = ram_design;\rif (backup + system) {\rfile.readPoint = network_native;\rsidebar_engine_device(cell_tftp_raster,\rdual_login_paper.adf_vci.application_reader_design(\rgraphicsNvramCdma, lpi_footer_snmp, integer_model));\r}\rLocis suis novi cum suoque decidit eadem\r#\rIdmoniae ripis, at aves, ali missa adest, ut et autem, et ab?\n"},{"id":12,"href":"/docs/shortcodes/buttons/","title":"Buttons","section":"Shortcodes","content":"\rButtons\r#\rButtons are styled links that can lead to local page or external link.\nExample\r#\r{{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}} Get Home\rContribute\r"},{"id":13,"href":"/docs/shortcodes/columns/","title":"Columns","section":"Shortcodes","content":"\rColumns\r#\rColumns help organize shorter pieces of content horizontally for readability.\n{{\u0026lt; columns \u0026gt;}} \u0026lt;!-- begin columns block --\u0026gt; # Left Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Mid Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Right Content Lorem markdownum insigne... {{\u0026lt; /columns \u0026gt;}} Example\r#\rLeft Content\r#\rLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nMid Content\r#\rLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!\nRight Content\r#\rLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n"},{"id":14,"href":"/docs/shortcodes/details/","title":"Details","section":"Shortcodes","content":"\rDetails\r#\rDetails shortcode is a helper for details html5 element. It is going to replace expand shortcode.\nExample\r#\r{{\u0026lt; details \u0026#34;Title\u0026#34; [open] \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} {{\u0026lt; details title=\u0026#34;Title\u0026#34; open=true \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} Title\rMarkdown content\r#\rLorem markdownum insigne\u0026hellip;\n"},{"id":15,"href":"/docs/shortcodes/expand/","title":"Expand","section":"Shortcodes","content":"\rExpand\r#\rExpand shortcode can help to decrease clutter on screen by hiding part of text. Expand content by clicking on it.\nExample\r#\rDefault\r#\r{{\u0026lt; expand \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}} Expand\r↕\rMarkdown content\r#\rLorem markdownum insigne\u0026hellip;\nWith Custom Label\r#\r{{\u0026lt; expand \u0026#34;Custom Label\u0026#34; \u0026#34;...\u0026#34; \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}} Custom Label\r...\rMarkdown content\r#\rLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n"},{"id":16,"href":"/docs/shortcodes/hints/","title":"Hints","section":"Shortcodes","content":"\rHints\r#\rHint shortcode can be used as hint/alerts/notification block.\nThere are 3 colors to choose: info, warning and danger.\n{{\u0026lt; hint [info|warning|danger] \u0026gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{\u0026lt; /hint \u0026gt;}} Example\r#\rMarkdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\rMarkdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\rMarkdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa\r"},{"id":17,"href":"/docs/shortcodes/section/","title":"Section","section":"Shortcodes","content":"\rSection\r#\rSection renders pages in section as definition list, using title and description.\nExample\r#\r{{\u0026lt; section \u0026gt;}} Page1\rPage2\r"},{"id":18,"href":"/docs/shortcodes/section/page1/","title":"Page1","section":"Section","content":"\rPage 1\r#\r"},{"id":19,"href":"/docs/shortcodes/section/page2/","title":"Page2","section":"Section","content":"\rPage 2\r#\r"},{"id":20,"href":"/docs/shortcodes/tabs/","title":"Tabs","section":"Shortcodes","content":"\rTabs\r#\rTabs let you organize content by context, for example installation instructions for each supported platform.\n{{\u0026lt; tabs \u0026#34;uniqueid\u0026#34; \u0026gt;}} {{\u0026lt; tab \u0026#34;MacOS\u0026#34; \u0026gt;}} # MacOS Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Linux\u0026#34; \u0026gt;}} # Linux Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Windows\u0026#34; \u0026gt;}} # Windows Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}} Example\r#\rMacOS\rMacOS\r#\rThis is tab MacOS content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nLinux\rLinux\r#\rThis is tab Linux content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nWindows\rWindows\r#\rThis is tab Windows content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n"}]