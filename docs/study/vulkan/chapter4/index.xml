<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>chapter4 同步 on YCK-DZ</title>
    <link>http://localhost:1313/docs/study/vulkan/chapter4/</link>
    <description>Recent content in chapter4 同步 on YCK-DZ</description>
    <generator>Hugo 0.125.0</generator>
    <language>zh-CN</language>
    <atom:link href="http://localhost:1313/docs/study/vulkan/chapter4/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>pipeline</title>
      <link>http://localhost:1313/docs/study/vulkan/chapter4/1-pipeline/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/vulkan/chapter4/1-pipeline/</guid>
      <description>Pipeline overview&#xD;#&#xD;stage&#xD;#&#xD;TOP_OF_PIPE_BIT&#xA;DRAW_INDIRECT_BIT&#xA;VERTEX_INPUT_BIT&#xA;VERTEX_SHADER_BIT&#xA;TESSELLATION_CONTROL_SHADER_BIT&#xA;TESSELLATION_EVALUATION_SHADER_BIT&#xA;GEOMETRY_SHADER_BIT&#xA;FRAGMENT_SHADER_BIT&#xA;EARLY_FRAGMENT_TESTS_BIT&#xA;LATE_FRAGMENT_TESTS_BIT&#xA;COLOR_ATTACHMENT_OUTPUT_BIT&#xA;TRANSFER_BIT&#xA;COMPUTE_SHADER_BIT&#xA;BOTTOM_OF_PIPE_BIT&#xA;HOST_BIT&#xA;ALL_GRAPHICS_BIT&#xA;ALL_COMMANDS_BIT&#xA;source&#xD;#&#xD;生产阶段&#xA;target&#xD;#&#xD;消费阶段&#xA;source 之后 target 之前&#xA;vkCmdPipelineBarrier( commandBuffer, VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT, // source stage VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, // destination stage /* remaining parameters omitted */); 这种转换表示，GPU 上当前正在进行的所有命令都需要完成，然后才执行该转换，并且在它完成转换之前，不允许任何命令开始。这个障碍会等待一切完成，并阻止任何工作在它开始之前启动。&#xA;vkCmdPipelineBarrier( commandBuffer, VK_PIPELINE_VERTEX_SHADER_BIT, // source stage VK_PIPELINE_COMPUTE_SHADER_BIT, // destination stage /* remaining parameters omitted */); If you write to a render target and read from it in a fragment shader, the stages would be VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT as the source and VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT as the destination – typical for G-Buffer rendering.</description>
    </item>
    <item>
      <title>vkCmdBlitImage</title>
      <link>http://localhost:1313/docs/study/vulkan/chapter4/2-blit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/docs/study/vulkan/chapter4/2-blit/</guid>
      <description>要在原始图像的基础上生成 Mipmap，可以通过使用多个图像传输操作来实现。在每个 Mipmap 级别，图像的尺寸会减小一半，并且可以根据需要使用不同的过滤器来处理像素数据。&#xA;以下是一个基于原始图像生成 Mipmap 的简单示例：&#xA;// 1. 创建源和目标图像的视图 // 创建源图像视图 VkImageViewCreateInfo srcImageViewInfo = {}; srcImageViewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO; srcImageViewInfo.image = srcImage; // srcImage 是原始图像 srcImageViewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D; srcImageViewInfo.format = srcFormat; // srcFormat 是原始图像格式 srcImageViewInfo.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT; srcImageViewInfo.subresourceRange.baseMipLevel = 0; srcImageViewInfo.subresourceRange.levelCount = 1; srcImageViewInfo.subresourceRange.baseArrayLayer = 0; srcImageViewInfo.subresourceRange.layerCount = 1; VkImageView srcImageView; vkCreateImageView(device, &amp;amp;srcImageViewInfo, nullptr, &amp;amp;srcImageView); // 创建目标图像视图 VkImageViewCreateInfo dstImageViewInfo = {}; dstImageViewInfo.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO; dstImageViewInfo.image = srcImage; // 目标图像和原始图像使用同一个图像对象 dstImageViewInfo.viewType = VK_IMAGE_VIEW_TYPE_2D; dstImageViewInfo.</description>
    </item>
  </channel>
</rss>
